import org.objectweb.asm.ClassWriter
import org.objectweb.asm.ModuleVisitor
import org.objectweb.asm.Opcodes

import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.StandardOpenOption

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath group: 'org.ow2.asm', name: 'asm', version: '9.8'
    }
}

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'signing'
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0'
}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
    compileJava.options.encoding('UTF-8')
    withSourcesJar()
    withJavadocJar()
}

def tomcatVersion = '10.1.44'

group = 'io.github.amayaframework'
archivesBaseName = 'tomcat-embed-websocket'
version = tomcatVersion + (System.getenv('SUFFIX_VERSION') ?: '')

repositories {
    mavenCentral()
}

ext {
    sourceArtifact = [
            group: 'org.apache.tomcat.embed',
            name: 'tomcat-embed-websocket',
            version: tomcatVersion
    ]
    packagesToRemove = ['jakarta']
}

configurations {
    binJar {
        transitive = false
    }
    srcJar {
        transitive = false
    }
}

dependencies {
    binJar "${sourceArtifact.group}:${sourceArtifact.name}:${sourceArtifact.version}"
    srcJar "${sourceArtifact.group}:${sourceArtifact.name}:${sourceArtifact.version}:sources"
    // Websocket API
    api group: 'jakarta.websocket', name: 'jakarta.websocket-api', version: '2.1.1'
    // Tomcat Core
    compileOnly group: 'io.github.amayaframework', name: 'tomcat-embed-core', version: '10.1.44-4'
}

static def isEmpty(Path path) {
    if (Files.isDirectory(path)) {
        try (var directory = Files.newDirectoryStream(path)) {
            return !directory.iterator().hasNext();
        }
    }
    return false;
}

def buildDirectory = layout.buildDirectory.get()
def extractedClasses = buildDirectory.dir("extractedClasses")
def extractedSources = buildDirectory.dir("extractedSources")

tasks.register('extractClasses', Copy) {
    description = 'Extracts binary jar and removes specified packages'

    from {
        configurations.binJar.collect { zipTree(it) }
    }
    into "${extractedClasses}"

    // Exclude unwanted packages
    exclude { fileTreeElement ->
        def path = fileTreeElement.relativePath.pathString
        return packagesToRemove.any { pkg ->
            path.startsWith(pkg.replace('.', '/') + '/')
        }
    }

    exclude 'module-info*'

    doLast {
        Files.walk(Path.of("${extractedClasses}"))
                .filter { isEmpty(it) }
                .forEach {Files.delete(it)}

        println "Source code extracted to ${extractedClasses}"
        println "Removed packages: ${packagesToRemove.join(', ')}"
    }
}

tasks.register('extractSources', Copy) {
    description = 'Extracts sources jar and removes specified packages'

    from {
        configurations.srcJar.collect { zipTree(it) }
    }
    into "${extractedSources}"

    // Exclude unwanted packages
    exclude { fileTreeElement ->
        def path = fileTreeElement.relativePath.pathString
        return packagesToRemove.any { pkg ->
            path.startsWith(pkg.replace('.', '/') + '/')
        }
    }

    exclude 'module-info*'

    doLast {
        Files.walk(Path.of("${extractedSources}"))
                .filter { isEmpty(it) }
                .forEach {Files.delete(it)}

        println "Source code extracted to ${extractedSources}"
        println "Removed packages: ${packagesToRemove.join(', ')}"
    }
}

class ModuleDependency {
    final String action;
    final String[] mods;
    final String module;

    ModuleDependency(String action, String[] mods, String module) {
        this.action = action
        this.mods = mods
        this.module = module
    }
}

class ModuleInfo {
    final boolean opened;
    final String name;
    final List<ModuleDependency> deps;

    ModuleInfo(boolean opened, String name, List<ModuleDependency> deps) {
        this.opened = opened
        this.name = name
        this.deps = deps
    }
}

static def parseModuleLine(String line) {
    def split = line.split(" ");
    if (split.length < 2) {
        throw new GradleException("Bad module-info template: dependency line must have at least two args")
    }
    if (split.length == 2) {
        return new ModuleDependency(split[0], new String[0], split[1].replace(";", ""))
    }
    def mods = new String[split.length - 2]
    for (var i = 1; i < split.length - 1; ++i) {
        mods[i - 1] = split[i]
    }
    return new ModuleDependency(split[0], mods, split[split.length - 1].replace(";", ""))
}

static def parseModuleInfo(Path path) {
    try (def reader = Files.newBufferedReader(path)) {
        def first = reader.readLine().replace("{", "").strip()
        def opened = first.startsWith("open")
        def name = first.replace("open", "").replace("module", "").strip()
        def deps = new LinkedList<ModuleDependency>()
        while (true) {
            def line = reader.readLine()
            if (line == null) {
                break
            }
            line = line.strip()
            if (line.isEmpty() || line.startsWith("//") || line == "{" || line == "}") {
                continue
            }
            deps.add(parseModuleLine(line))
        }
        return new ModuleInfo(opened, name, deps)
    }
}

static def generateAccess(String[] modifiers) {
    def ret = 0
    for (def mod : modifiers) {
        if (mod == "transitive") {
            ret |= Opcodes.ACC_TRANSITIVE
        } else if (mod == "static") {
            ret |= Opcodes.ACC_STATIC_PHASE
        }
    }
    return ret
}

static def generateModuleDependency(ModuleVisitor mv, ModuleDependency dep) {
    def access = generateAccess(dep.mods)
    if (dep.action == "requires") {
        mv.visitRequire(dep.module, access, null)
    } else if (dep.action == "exports") {
        mv.visitExport(dep.module, access, null)
    } else if (dep.action == "uses") {
        mv.visitUse(dep.module)
    } else if (dep.action == "provides") {
        mv.visitProvide(dep.mods[0], dep.module)
    }
}

static def generateModuleInfo(ModuleInfo info) {
    def writer = new ClassWriter(0)
    writer.visit(Opcodes.V9, Opcodes.ACC_MODULE, "module-info", null, null, null)
    def mv = writer.visitModule(info.name, info.opened ? Opcodes.ACC_OPEN : 0, null)
    info.deps.forEach {generateModuleDependency(mv, it)}
    mv.visitEnd()
    writer.visitEnd()
    return writer.toByteArray()
}


def resourcesDir = layout.projectDirectory
        .dir("src")
        .dir("main")
        .dir("resources")
def sourceModuleInfo = resourcesDir.file("module-info.java")
def generatedModuleInfo = buildDirectory.dir("generatedModuleInfo").file("module-info.class")

tasks.register('generateModuleInfo') {
    description = 'Generates module-info.class from module-info.java'

    doLast {
        def moduleInfo = parseModuleInfo(sourceModuleInfo.asFile.toPath())
        def bytecode = generateModuleInfo(moduleInfo)
        def targetPath = generatedModuleInfo.asFile.toPath()
        Files.createDirectories(targetPath.parent)
        Files.write(
                targetPath,
                bytecode,
                StandardOpenOption.CREATE,
                StandardOpenOption.TRUNCATE_EXISTING
        )
    }
}

task jar(type: Jar, overwrite: true) {
    description = 'Builds main JAR from extracted classes and generated module-info'
    archiveClassifier = ''
    processResources.exclude('*')

    dependsOn extractClasses, generateModuleInfo

    from extractedClasses
    from generatedModuleInfo

    manifest {
        from("$extractedClasses/META-INF/MANIFEST.MF")
    }
}

task sourcesJar(type: Jar, overwrite: true) {
    description = 'Builds sources JAR from extracted sources and source module-info'
    archiveClassifier = 'sources'
    processResources.exclude('*')
    exclude('module-info*')

    dependsOn extractSources

    from extractedSources

    manifest {
        from("$extractedSources/META-INF/MANIFEST.MF")
    }
}

def javadocDir = buildDirectory.dir("docs").dir("javadoc")
def originalDocReference = "https://tomcat.apache.org/tomcat-10.1-doc/web-socket-howto.html#Overview"

task javadocJar(type: Jar, overwrite: true) {
    description = 'Generates a placeholder Javadoc JAR with reference to official documentation'
    archiveClassifier = 'javadoc'

    // Создаем минимальный javadoc
    doFirst {
        javadocDir.asFile.mkdirs()

        // Создаем базовый index.html
        def indexFile = javadocDir.file("index.html").asFile
        indexFile.text = """
<!DOCTYPE html>
<html>
<head>
    <title>Javadoc - ${project.name}</title>
</head>
<body>
    <h1>${project.name} ${project.version}</h1>
    <p>This is a repackaged version of Apache Tomcat Embed Websocket.</p>
    <p>Original documentation can be found at: 
    <a href="${originalDocReference}">Apache Tomcat API Documentation</a></p>
</body>
</html>
        """.trim()
    }

    from javadocDir
}

signing {
    sign publishing.publications
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            // Configure pom
            pom {
                name.set(archivesBaseName)
                description.set('Repackaged Apache Tomcat Embed Websocket (with proper JPMS dependencies)')
                url.set('https://github.com/AmayaFramework/amaya-tomcat')

                organization {
                    name.set('io.github.amayaframework')
                    url.set('https://github.com/AmayaFramework')
                }

                issueManagement {
                    system.set('GitHub')
                    url.set('https://github.com/AmayaFramework/amaya-tomcat/issues')
                }

                licenses {
                    license {
                        name.set('Apache License 2.0')
                        url.set('https://github.com/AmayaFramework/amaya-tomcat/blob/main/LICENSE')
                    }
                }

                scm {
                    url.set('https://github.com/AmayaFramework/amaya-tomcat')
                    connection.set('scm:https://github.com/AmayaFramework/amaya-tomcat.git')
                    developerConnection.set('scm:https://github.com/AmayaFramework/amaya-tomcat.git')
                }

                developers {
                    developer {
                        id.set('RomanQed')
                        name.set('Roman Bakaldin')
                        email.set('gbakaldin@gmail.com')
                    }
                }
            }
        }
    }
}

nexusPublishing {
    repositories {
        sonatype {
            username = centralUsername
            password = centralPassword
            nexusUrl.set(uri("https://ossrh-staging-api.central.sonatype.com/service/local/"))
            snapshotRepositoryUrl.set(uri("https://central.sonatype.com/repository/maven-snapshots/"))
        }
    }
}
